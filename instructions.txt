# Prompt for LLM — Build **The Tiny Scroll** (bible.korze.org)

You are a senior frontend engineer + product designer. Build a tiny, delightful web experience called **“The Tiny Scroll.”** It shows Bible text **one line at a time** through a thin horizontal slit. The user **pulls** (click/drag or touch/drag) to reveal the next line with a **tape-measure / elastic** feel. On release, it **snaps** to the nearest line. Provide a minimal, artsy, respectful vibe (in the spirit of grass.korze and playful micro-sites).

## 0) Project shape & constraints
- **No frameworks** for v1. Use **vanilla HTML/CSS/JS** (one `index.html`, `styles.css`, `main.js`, plus an `assets/` folder). Keep JS under ~300 lines if possible.
- Must run as a **static site** (just open `index.html`).
- **No build step** required; optional extras (SW, favicons) are okay but not mandatory.
- Use **public-domain** Bible text only (e.g., **KJV** or **WEB**). Include a small local JSON file with a few passages for demo.
- Prioritize **accessibility**, **performance** (<50KB gzipped core), and **mobile**.
- Include a **permalink** scheme so users can share a specific passage and line.

## 1) Visual & interaction design

### Layout
- The page has three vertical regions:
  1. **Top chrome** (24–36px tall): left = logo word “tiny scroll”; right = info button “i”.
  2. **View slit**: fixed height equal to **exactly 1 line of text** (line-height), centered on the page. This is the only place where content is visible.
  3. **Bottom controls**: compact row with: translation picker, passage picker, share button, theme toggle.
- The verses themselves are stacked vertically inside an **invisible reel**, but only one line is revealed through the slit.

### Aesthetic
- **Minimal, typographic**. Big friendly type, generous tracking, calm spacing.
- **Light theme** default; **dark theme** available.
- Subtle **grain/noise** background at 2–4% opacity (CSS background image or data-URI SVG noise).
- Use **system font stack** for performance: `-apple-system, Segoe UI, Inter, Roboto, "Helvetica Neue", Arial, sans-serif`.
- **Design tokens** (CSS variables):
  ```css
  :root {
    --bg: #f9f7f3;
    --ink: #1b1b1b;
    --muted: #6b6b6b;
    --accent: #7a5af8; /* subtle violet */
    --lineHeight: 1.6; /* used for math */
    --fontSize: clamp(18px, 4vw, 28px);
    --radius: 14px;
    --shadow: 0 8px 24px rgba(0,0,0,.08);
    --grain: url('assets/grain.png'); /* tiny 64x64 png repeated */
  }
  .dark {
    --bg: #0f1013;
    --ink: #eaeaea;
    --muted: #9aa0a6;
    --accent: #9b8cff;
  }
  ```
- **Slit styling**:
  - A rounded rectangle container with **soft inner shadow** and a **mask** that restricts visibility to one line:
    - Either set the container height to exactly `line-height` and `overflow: hidden`, **or**
    - Use `mask-image: linear-gradient(to bottom, transparent 0, black 25%, black 75%, transparent 100%)` for a faint feather (optional).
  - Subtle **gloss**: a 1px white highlight at the top edge in light theme (reduce in dark).

### Motion & “elastic pull” feel
- Dragging vertically moves the internal reel.
- Allow **overscroll** by ~0.6 line above/below to get elasticity.
- On release:
  - Compute the nearest **integer line index**.
  - Animate **spring snap** back to that index.
- **Spring parameters** (tweakable):
  - Tension/stiffness ≈ `300`, damping ≈ `28`, mass ≈ `1`.
  - Cap duration to **350ms** max for long snaps; min 140ms.
- **Pointer affordances**:
  - On pointer down inside slit: cursor changes to `ns-resize`.
  - On touch: a very subtle **haptic** (if available) when crossing line boundaries.

### Micro-interactions
- Crossing a line boundary plays a **very quiet tick** (2–3 dB above silence) — keep audio **off by default**; enable with a toggle in the info modal.
- Press & hold on the slit for 500ms: a faint **parchment texture** appears behind text, fading out on release.

## 2) UX details & controls

### Controls (bottom bar)
- **Translation** select: `KJV`, `WEB` (public domain).
- **Passage** select: include 3–5 demos (e.g., `Psalm 23`, `John 1:1–14`, `Genesis 1:1–5`, `Matthew 5:3–10`).
- **Share** button: copies a URL like:
  ```
  /?t=KJV&p=Psalm%2023&line=4&theme=dark
  ```
- **Theme** toggle: sun/moon icon, persists to `localStorage`.

### Keyboard & screen reader support
- Slit container is **focusable**.
- Keys:
  - `ArrowDown`/`PageDown` = advance 1 line (or 3 lines with PageDown).
  - `ArrowUp`/`PageUp` = back.
  - `Home/End` jump to first/last line.
- Use **ARIA live region** (`aria-live="polite"`) that announces the currently visible line (e.g., “Psalm 23, line 4 of 6: *He restoreth my soul…*”).
- Buttons have visible focus states and `aria-pressed` where appropriate.
- **Reduced motion** query respected: if `prefers-reduced-motion`, disable spring and snap instantly.

### Copy & tone
- Keep playful copy in the **chrome only** (e.g., tooltip on share: “link to this exact sliver”).
- Keep scripture text **unaltered** and un-snarked.

## 3) Data model & text wrapping

### Verse store (local JSON)
Create `passages.json`:
```json
{
  "KJV": {
    "Psalm 23": "The Lord is my shepherd; I shall not want...\n...",
    "John 1:1–14": "In the beginning was the Word, and the Word was with God..."
  },
  "WEB": {
    "Psalm 23": "Yahweh is my shepherd; I shall lack nothing..."
  }
}
```

### Lineization
- Render the selected passage into lines **at runtime** so the slit always shows *exactly one* line regardless of viewport.
- Approach:
  1. Measure text using an offscreen element with the same font, size, and width as the reel.
  2. Use CSS `line-height: var(--lineHeight)` and **prevent wrapping mid-word**: `word-break: normal; hyphens: auto` (only if hyphenation is desired; else `hyphens: none`).
  3. Insert line breaks by letting the browser wrap and then **read client rects** to group nodes by line (common technique: wrap each word in a span and detect `.getClientRects()` changes).
  4. Cache the computed array of lines (strings) for the current viewport; recompute on resize (debounced).
- The reel’s vertical translate is always `-currentLineIndex * lineHeightPx`.

## 4) Drag physics & snapping (implementation spec)

### State
```ts
state = {
  lines: string[],
  lineHeightPx: number,
  current: 0,          // integer line index
  dragStartY: 0,
  dragStartOffset: 0,  // current * lineHeightPx at pointerdown
  offsetPx: 0,         // live pixel offset during drag
  maxIndex: lines.length - 1,
  overscrollPx: 0.6 * lineHeightPx
}
```

### Drag
- On `pointerdown` inside slit:
  - `setPointerCapture`.
  - `dragStartY = event.clientY`.
  - `dragStartOffset = state.current * lineHeightPx`.
- On `pointermove` while captured:
  - `delta = event.clientY - dragStartY`.
  - `raw = dragStartOffset + delta`.
  - Clamp with **rubberbanding**:
    ```js
    function rubberClamp(x, min, max, k = 0.6) {
      if (x < min) return min - (min - x) * k;
      if (x > max) return max + (x - max) * k;
      return x;
    }
    const minPx = 0;
    const maxPx = state.maxIndex * state.lineHeightPx;
    state.offsetPx = rubberClamp(raw, minPx - state.overscrollPx, maxPx + state.overscrollPx);
    translateReel(-state.offsetPx);
    ```
  - If `Math.round(state.offsetPx / lineHeightPx)` changes, trigger a **tick** (if audio enabled) and **haptic** (`navigator.vibrate(8)`).
- On `pointerup`:
  - Compute target index: `Math.round(offsetPx / lineHeightPx)`, clamp 0..maxIndex.
  - Start **spring** animation from current offset to `targetIndex * lineHeightPx`.
  - On each frame, update transform; on settle, set `state.current = targetIndex` and update URL.

### Spring (if no library)
- Implement a **RK4** or simple **critically damped** spring. Pseudocode (velocity Verlet-ish):
  ```js
  let x = currentPx, v = 0, target = targetPx, dt = 1/60;
  const k = 300, c = 28, m = 1; // stiffness, damping, mass
  function step() {
    const F = -k * (x - target) - c * v;
    const a = F / m;
    v += a * dt;
    x += v * dt;
    if (Math.abs(v) < 0.01 && Math.abs(x - target) < 0.5) { x = target; end(); }
    else { translateReel(-x); requestAnimationFrame(step); }
  }
  step();
  ```
- Respect `prefers-reduced-motion`: set `x = target` immediately, no spring.

## 5) Routing, share links, and persistence
- On load, parse `location.search`:
  - `t` (translation), `p` (passage), `line` (integer), `theme` (`dark|light`).
- After a snap, push state via `history.replaceState` with updated `line`.
- Persist last used `t`, `p`, `theme` to `localStorage`.
- If an unknown query param or bad combination occurs, gracefully fall back to first available passage.

## 6) Accessibility checklist
- Slit has `role="region"` with `aria-label="Scripture line viewer"`.
- Live text has visually hidden element with `aria-live="polite"` announcing:
  - `"{passage}, line {i+1} of {n}: {lineText}"`
- All controls are keyboard reachable; focus ring is clear (`outline: 2px solid var(--accent)`).
- Contrast ratio ≥ 4.5:1 for text and ≥ 3:1 for icons.
- Respect `prefers-reduced-motion` and user’s OS theme (`prefers-color-scheme`).
- Audio off by default; toggle is labeled and stateful.

## 7) Performance & quality bar
- **No layout thrash**: batch reads/writes; use a single `transform: translateY()` for reel.
- **Debounce resize** to recompute lines (200ms).
- Inline critical CSS (first ~4KB) in `<head>`, load rest async (optional).
- Lighthouse targets (mobile): Performance ≥ 95, Accessibility ≥ 95, Best Practices ≥ 95.

## 8) Files to output
- `index.html` — semantic structure, controls, info modal.
- `styles.css` — tokens, themes, layout, focus states, animations.
- `main.js` — data load, lineization, drag physics, a11y announcements, routing.
- `passages.json` — small demo passages (public domain).
- `assets/grain.png`, `assets/tick.mp3` (very short), `assets/icon-*.svg`.
- (Optional) `sw.js` — cache `index.html`, CSS/JS, passages JSON for offline.
- `README.md` — how to run, how to add passages, license notes.

## 9) Acceptance tests (manual or Cypress)
1. **Single line**: At any viewport width, exactly one line is visible (no clipping).
2. **Drag & snap**: Drag down ~1.2 line heights and release → snaps to next line within 350ms.
3. **Keyboard**: ArrowDown advances one line; Home/End jump correctly; focus indicator visible.
4. **Share**: Clicking Share copies a URL; reloading that URL restores translation/passage/line.
5. **Resize**: After rotating phone, lines reflow and current visible *semantic* line is preserved (approximate to nearest by character index).
6. **A11y**: Screen reader announces current line on snap; controls have labels/roles.
7. **Reduced motion**: With `prefers-reduced-motion`, snap is instant.
8. **Dark theme**: Toggle works; state persists and is reflected in URL if present.
9. **No script errors** in console during common flows.

## 10) Stretch (optional, nice-to-haves)
- **Auto-scroll mode**: play/pause button that advances one line every N seconds.
- **Tap to step**: single tap/click on bottom half = next line; top half = previous line.
- **Verse numbers**: small superscript numbers fading in on hover/focus.
- **Guide dot**: left edge shows a tiny progress dot (line i/n) that animates on snap.
- **Copy line**: long-press or ⌘C to copy current line text (with reference appended).

## 11) Respect & licensing
- Use only **public-domain** translations (KJV, WEB). Include attribution in the info modal:
  - “Text: King James Version (Public Domain) and World English Bible (Public Domain).”
- Do not modify scripture text. Typography/styling only.

## 12) Implementation notes & snippets

### HTML skeleton (outline only)
```html
<body>
  <header class="top">
    <div class="brand">tiny scroll</div>
    <button id="infoBtn" aria-label="About">i</button>
  </header>

  <main>
    <div id="slit" tabindex="0" role="region" aria-label="Scripture line viewer">
      <div id="reel" aria-hidden="true"></div>
      <div class="sr-only" aria-live="polite" id="live"></div>
    </div>
  </main>

  <footer class="controls">
    <select id="translation"></select>
    <select id="passage"></select>
    <button id="shareBtn">share</button>
    <button id="themeBtn" aria-pressed="false">dark</button>
  </footer>

  <dialog id="info">…attribution, toggles…</dialog>
</body>
```

### CSS essentials
```css
html,body { height: 100%; background: var(--bg); color: var(--ink); }
.top, .controls { display:flex; align-items:center; justify-content:space-between; padding: 10px 14px; }
#slit {
  width: min(820px, 92vw);
  margin: 6vh auto;
  border-radius: var(--radius);
  box-shadow: var(--shadow);
  background: linear-gradient(#fff6, #fff0), var(--grain);
  overflow: hidden;
  line-height: var(--lineHeight);
  font-size: var(--fontSize);
  /* exact one line: */
  height: calc(1em * var(--lineHeight));
  position: relative;
}
#reel { will-change: transform; }
.sr-only { position:absolute; left:-9999px; width:1px; height:1px; overflow:hidden; }
```

### JS outline
```js
const qs = sel => document.querySelector(sel);
const slit = qs('#slit');
const reel = qs('#reel');
const live = qs('#live');

let state = { lines: [], lineHeightPx: 0, current: 0, offsetPx: 0, … };

async function boot() {
  await loadData();
  applyThemeFromURLorStorage();
  setPassageFromURL();
  lineize();
  bindControls();
  jumpTo(parseInt(getQuery('line')) || 0, false);
}
function lineize() { /* measure + build spans into #reel, update state.lineHeightPx */ }
function jumpTo(i, animate=true) { /* spring or instant based on prefers-reduced-motion */ }
function onPointerDown(e) { /* capture + rubberband drag */ }
function onPointerMove(e) { /* update offset; tick on boundary cross */ }
function onPointerUp(e) { /* snap to nearest line; update URL + live region */ }
function updateLive() { live.textContent = `${passage}, line ${state.current+1} of ${state.lines.length}: ${state.lines[state.current]}`; }
function updateURL() { /* history.replaceState with t, p, line, theme */ }

boot();
```

---

## What to output (deliverables)
1. All files listed in section **8** with working code.
2. A short **README.md** describing how to add more passages and adjust the spring.
3. Brief comments in `main.js` marking the **three tweak points**: typography, spring, overscroll.

If anything above conflicts, **favor accessibility and performance** over visual flourish.
